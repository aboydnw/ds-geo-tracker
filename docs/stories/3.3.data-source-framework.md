# Story 3.3: Data Source Convention

## Status
Draft

## Story
**As a** developer,
**I want** a consistent pattern for adding data sources,
**so that** new integrations follow a predictable structure.

## Acceptance Criteria
1. Data sources are modular files in `src/sources/` directory
2. Each source exports standard interface: `{ name, enabled, fetchData }`
3. Sources are explicitly imported in `src/sources/index.js` (no dynamic filesystem discovery)
4. Sources can be enabled/disabled via environment variables
5. Failed sources don't block other sources from running

## Tasks / Subtasks
- [ ] Define data source interface (AC: 2)
  - [ ] Document required exports with JSDoc
  - [ ] Create example source template (`src/sources/_template.js`)
- [ ] Create `src/sources/index.js` barrel file (AC: 1, 3)
  - [ ] Explicitly import google-trends and github-stats sources
  - [ ] Export a `getEnabledSources()` function that filters by `enabled` flag
- [ ] Add enable/disable logic (AC: 4)
  - [ ] Each source checks its own env var (e.g., `ENABLE_GOOGLE_TRENDS`)
  - [ ] Export `enabled` property based on config
  - [ ] Skip disabled sources in loader
- [ ] Implement isolated execution (AC: 5)
  - [ ] Wrap each source execution in try/catch
  - [ ] Log failures per source
  - [ ] Continue with remaining sources
  - [ ] Report source status in summary
- [ ] Refactor existing sources to new interface
  - [ ] Update google-trends.js to match interface
  - [ ] Update github-stats.js to match interface
- [ ] Update main script to use source loader
  - [ ] Import `getEnabledSources` from sources/index.js
  - [ ] Execute all enabled sources
  - [ ] Aggregate results into event props

## Dev Notes
**Source Interface:**
```javascript
/**
 * @typedef {Object} DataSource
 * @property {string} name - Human-readable source name
 * @property {boolean} enabled - Whether source is active (based on env var)
 * @property {function} fetchData - Async function: (queries) => enrichment data
 */

// Example: src/sources/my-source.js
export default {
  name: 'My Custom Source',
  enabled: process.env.ENABLE_MY_SOURCE === 'true',

  async fetchData(queries) {
    // Fetch and return enrichment data
    // Return array of { queryId, data } objects
    return [];
  }
};
```

**Source Loader (explicit imports, no dynamic discovery):**
```javascript
// src/sources/index.js
import googleTrends from './google-trends.js';
import githubStats from './github-stats.js';

const ALL_SOURCES = [googleTrends, githubStats];

export function getEnabledSources() {
  return ALL_SOURCES.filter(source => source.enabled);
}
```

**Why explicit imports instead of dynamic discovery?**
Dynamic filesystem scanning (`fs.readdirSync` + `import()`) adds complexity, introduces potential security concerns with arbitrary module loading, and makes it harder to understand what sources exist at a glance. With only 2-3 sources planned, explicit imports are simpler, more debuggable, and just as maintainable. If the project grows to 10+ sources, dynamic discovery can be reconsidered.

**Directory Structure:**
```
src/
├── sources/
│   ├── index.js           # Source barrel file (explicit imports)
│   ├── google-trends.js   # Google Trends source (Story 3.1)
│   ├── github-stats.js    # GitHub stats source (Story 3.2)
│   └── _template.js       # Template for new sources
├── plausible.js
├── queries.js
└── config.js
```

**Execution Flow:**
1. Load all enabled sources via `getEnabledSources()`
2. For each query, run through all enabled sources
3. Merge enrichment data into event props
4. Send combined event to Plausible

### Testing
- Create test source that always succeeds
- Create test source that always fails
- Verify failed source doesn't block others
- Verify summary shows source status
- Verify disabled source (env var unset) is not executed

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1 | Initial story created | PO Agent |
| 2026-02-05 | 0.2 | Simplified: explicit imports instead of dynamic discovery | Reviewer |
